<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Soul Trait Evolution (Live)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root {
      --bg: #f6f8fa;
      --fg: #222;
      --panel: #fff;
      --panel-alt: #e9eef3;
      --accent: #4a90e2;
      --accent2: #b2c7e1;
      --table-header: #e9eef3;
      --table-row: #f6f8fa;
      --dominant: #e3f2fd;
      --msg-ai1: #e3f2fd; /* Used for AI (Gemini) */
      --msg-ai2: #fce4ec; /* Was for AI2, can be repurposed or kept for differentiation if you add another AI */
      --msg-selfreply: #e0f2f1; /* Color for AI-SelfReply */
      --msg-meta: #7b8a99;
    }
    body.soft-blue {
      --bg: #eaf3fb; --fg: #223344; --panel: #f7fbff; --panel-alt: #dbeafe;
      --accent: #4a90e2; --accent2: #b2c7e1; --table-header: #dbeafe; --table-row: #eaf3fb;
      --dominant: #b3e5fc; --msg-ai1: #b3e5fc; --msg-ai2: #e1bee7; --msg-selfreply: #c8e6c9; --msg-meta: #607d8b;
    }
    body.solarized {
      --bg: #fdf6e3; --fg: #657b83; --panel: #f5eecb; --panel-alt: #eee8d5;
      --accent: #268bd2; --accent2: #b58900; --table-header: #eee8d5; --table-row: #fdf6e3;
      --dominant: #b58900; --msg-ai1: #eee8d5; --msg-ai2: #f5eecb; --msg-selfreply: #d0e0d0; --msg-meta: #657b83;
    }
    body.pastel {
      --bg: #f8f7fa; --fg: #4b3f72; --panel: #f3e8ff; --panel-alt: #e0c3fc;
      --accent: #a3cef1; --accent2: #f9c6c9; --table-header: #e0c3fc; --table-row: #f8f7fa;
      --dominant: #f9c6c9; --msg-ai1: #e0c3fc; --msg-ai2: #f9c6c9; --msg-selfreply: #d1c4e9; --msg-meta: #4b3f72;
    }
    body {
      background: var(--bg); color: var(--fg); font-family: sans-serif;
      transition: background 0.3s, color 0.3s; margin: 0; padding: 20px;
    }
    .tabs { display: flex; margin-bottom: 20px; flex-wrap: wrap; }
    .tab {
      padding: 12px 28px; background: var(--panel-alt); color: var(--fg);
      border-radius: 8px 8px 0 0; margin-right: 6px; margin-bottom: 6px; cursor: pointer;
      font-weight: 500; border: none; outline: none; transition: background 0.2s, color 0.2s;
    }
    .tab.active { background: var(--panel); color: var(--accent); }
    .tab-content { display: none; padding: 15px; background: var(--panel); border-radius: 0 8px 8px 8px; box-shadow: 0 2px 8px #0002; }
    .tab-content.active { display: block; }
    #barplot, #timeline-chart { width:100%; max-width:900px; height:350px; margin-bottom: 30px; }
    #trait-table, #discovered-table {
      background: var(--panel); color: var(--fg); font-family: 'Courier New', Courier, monospace;
      border-radius: 8px; max-width: 900px; margin: 0 auto 30px auto;
      border-collapse: collapse; width: 100%; box-shadow: 0 2px 8px #0002;
    }
    #trait-table th, #trait-table td, #discovered-table th, #discovered-table td {
      border: 1px solid var(--panel-alt); padding: 8px 12px; text-align: left;
    }
    #trait-table th, #discovered-table th { background: var(--table-header); color: var(--accent); font-weight: bold; }
    #trait-table tr.dominant { background: var(--dominant); }
    #terminal {
      background: var(--panel); color: var(--fg); /* Changed from --accent for better readability */
      font-family: 'Courier New', Courier, monospace; padding: 20px; border-radius: 8px;
      min-height: 120px; max-width: 900px; margin: 0 auto; white-space: pre-wrap; /* Changed from pre-line */
      word-break: break-word; overflow-wrap: break-word; box-shadow: 0 2px 8px #0002;
      border: 1px solid var(--panel-alt);
    }
    #conversation-log { /* Renamed from #conversation to avoid ID clash with tab content */
      background: var(--panel); color: var(--fg); font-family: 'Courier New', Courier, monospace;
      border-radius: 8px; max-width: 900px; margin: 0 auto 30px auto;
      padding: 20px; min-height: 200px; box-shadow: 0 2px 8px #0002;
      border: 1px solid var(--panel-alt); max-height: 500px; overflow-y: auto;
    }
    .msg {
      margin-bottom: 18px; padding: 10px 16px; border-radius: 6px;
      background: var(--panel-alt); color: var(--fg); max-width: 85%;
      box-shadow: 0 1px 4px #0001; line-height: 1.4;
    }
    .msg.ai { background: var(--msg-ai1); color: var(--fg); align-self: flex-start; } /* Generic AI */
    .msg.ai-selfreply { background: var(--msg-selfreply); color: var(--fg); align-self: flex-start; margin-left: 20px; }
    .msg .meta { font-size: 0.85em; color: var(--msg-meta); margin-bottom: 4px; }
    .msg .text { white-space: pre-wrap; /* Changed from pre-line for better formatting */ }
    .theme-select, input[type="password"], input[type="text"], textarea, button {
      margin-bottom:12px;padding:10px;border-radius:6px;border:1px solid var(--panel-alt);
      background:var(--panel);color:var(--fg); font-size: 1em; box-sizing: border-box;
    }
    button { background:var(--accent);color:#fff;border:none;cursor:pointer; }
    input[type="password"], input[type="text"], textarea { width: calc(100% - 22px); }
    .container { max-width: 900px; margin: 0 auto; }
  </style>
</head>
<body>
  <div id="api-key-setup" class="container" style="margin-top:40px;margin-bottom:30px;padding:30px;background:var(--panel);border-radius:10px;box-shadow:0 2px 8px #0002;">
    <h2>Enter Gemini API Key to Begin</h2>
    <p>Hugging Face functionality is currently not used by the backend.</p>
    <label for="gemini-key"><b>Gemini API Key:</b></label><br>
    <input id="gemini-key" type="password" placeholder="Your Gemini API Key"><br>
    <button id="set-keys-btn">Set API Key & Start</button>
    <span id="api-key-status" style="margin-left:20px; font-weight: bold;"></span>
  </div>

  <div id="main-dashboard" style="display:none;">
    <div class="container">
      <h1>Soul Trait Evolution (Live)</h1>
    </div>
    <div class="tabs container">
      <button class="tab active" onclick="showTab('traits-view')">Traits</button>
      <button class="tab" onclick="showTab('timeline-view')">Timeline</button>
      <button class="tab" onclick="showTab('conversation-view')">Conversation</button>
      <button class="tab" onclick="showTab('customization-view')">Customization</button>
    </div>

    <div id="traits-view" class="tab-content active container">
      <div id="barplot"></div>
      <h3 style="margin-top: 30px;">Current Trait Values</h3>
      <table id="trait-table"></table>
      <h3 style="margin-top: 30px;">Discovered Traits</h3>
      <table id="discovered-table"></table>
      <h3 style="margin-top: 30px;">Interpretation</h3>
      <div id="terminal">Waiting for data...</div>
    </div>

    <div id="timeline-view" class="tab-content container">
      <div id="timeline-chart"></div> </div>

    <div id="conversation-view" class="tab-content container">
      <div id="conversation-log"></div> </div>

    <div id="customization-view" class="tab-content container">
      <label for="theme-select"><b>Choose a theme:</b></label>
      <select id="theme-select" class="theme-select">
        <option value="">Light (Default)</option>
        <option value="soft-blue">Soft Blue</option>
        <option value="solarized">Solarized</option>
        <option value="pastel">Pastel</option>
      </select>
      <hr style="margin: 30px 0;">
      <label for="prompt-box"><b>Custom Reflection Prompt (Optional):</b></label><br>
      <textarea id="prompt-box" rows="4" placeholder="Enter your custom prompt for AI reflections here..."></textarea><br>
      <button id="set-prompt-btn">Set Custom Prompt</button>
      <span id="prompt-status" style="margin-left: 20px;"></span>
    </div>
  </div>

  <script>
    const GEMINI_MODEL_USED_BY_BACKEND = "models/gemini-2.0-flash"; // For display/info if needed

    document.getElementById('set-keys-btn').onclick = async function() {
      const geminiKey = document.getElementById('gemini-key').value.trim();
      const statusSpan = document.getElementById('api-key-status');
      
      if (!geminiKey) {
        statusSpan.textContent = 'Error: Gemini API Key is required.';
        statusSpan.style.color = 'red';
        return;
      }

      statusSpan.textContent = 'Validating API Key...';
      statusSpan.style.color = 'var(--accent)';
      
      try {
        const response = await fetch('/set_api_keys', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          // Backend only expects gemini_api_key based on latest Python script
          body: JSON.stringify({ gemini_api_key: geminiKey }) 
        });
        const responseData = await response.json();

        if (response.ok && responseData.status === 'ok') {
          statusSpan.textContent = 'Gemini API Key Accepted! Starting simulation...';
          statusSpan.style.color = 'green';
          document.getElementById('api-key-setup').style.display = 'none';
          document.getElementById('main-dashboard').style.display = 'block'; // Show all dashboard content
          connectWebSocket(); // Connect WebSocket only after successful validation
        } else {
          let errorMsg = 'Error: ';
          if (responseData.errors && responseData.errors.gemini_api_key) {
            errorMsg += responseData.errors.gemini_api_key;
          } else if (responseData.message) {
            errorMsg += responseData.message;
          } else {
            errorMsg += `Server responded with status ${response.status}. Check server logs.`;
          }
          statusSpan.textContent = errorMsg;
          statusSpan.style.color = 'red';
          console.error("API Key validation failed:", responseData);
        }
      } catch (e) {
        statusSpan.textContent = 'Error: Failed to send API key to server. Check network or server status.';
        statusSpan.style.color = 'red';
        console.error("Fetch error for /set_api_keys:", e);
      }
    };

    let ws; // WebSocket instance

    function connectWebSocket() {
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
      ws.onopen = () => {
        console.log('WebSocket connected!');
        document.getElementById('terminal').textContent = 'Connection established. Waiting for initial soul data...';
      };
      ws.onmessage = ws_onmessage_handler; // Defined below
      ws.onclose = (event) => {
        console.log('WebSocket disconnected:', event.reason || 'No reason provided', 'Code:', event.code);
        document.getElementById('terminal').textContent = `WebSocket disconnected. Code: ${event.code}, Reason: ${event.reason || 'N/A'}. Attempting to reconnect in 7s...`;
        // Consider a more robust reconnect strategy if needed
        setTimeout(() => { 
            // Only try to reconnect if API keys were successfully set initially
            if (document.getElementById('api-key-setup').style.display === 'none') {
                console.log("Attempting to reconnect WebSocket...");
                connectWebSocket(); // Try to reconnect
            }
        }, 7000);
      };
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        document.getElementById('terminal').textContent = 'WebSocket connection error. See browser console.';
      };
    }

    // Global variables to store data for charts if needed for redraws
    let currentTraitData = {};
    let currentHistoryData = [];
    let currentTraitNames = [];
    let currentTraitFirstSeen = {};
    let currentTraitColors = {}; // Store trait colors

    function ws_onmessage_handler(event) {
      try {
        let data = JSON.parse(event.data);
        console.log("Received data:", data); // Log received data to browser console

        // Store data globally for potential redraws or access by other functions
        currentTraitData = data.traits || {};
        currentHistoryData = data.history || [];
        currentTraitNames = data.trait_names || []; // Names of currently active traits
        currentTraitFirstSeen = data.trait_first_seen || {};
        currentTraitColors = data.trait_colors || {}; // Get trait colors

        // Dominance calculation
        let sum = Object.values(currentTraitData).reduce((a, b) => a + b, 0) || 1;
        let dominance = {};
        for (let k of Object.keys(currentTraitData)) {
          dominance[k] = (currentTraitData[k] / sum) * 100;
        }
        let dominantTrait = Object.keys(dominance).length > 0 
            ? Object.keys(dominance).reduce((a, b) => dominance[a] > dominance[b] ? a : b) 
            : 'N/A';
        
        // Update all visualizations
        updateBarPlot(currentTraitData, dominance, currentTraitColors);
        updateTraitTable(currentTraitData, dominance, dominantTrait, currentTraitColors);
        updateDiscoveredTable(currentTraitFirstSeen, currentTraitData, data.step, currentTraitColors);
        // For timeline, use all_traits_pca_order if available and X had data, else currentTraitNames
        let timelineTraitOrder = (data.all_traits_pca_order && data.all_traits_pca_order.length > 0) ? data.all_traits_pca_order : currentTraitNames;
        updateTimeline(currentHistoryData, timelineTraitOrder, currentTraitColors); 
        document.getElementById('terminal').textContent = interpret(currentTraitData, dominance, dominantTrait);
        updateConversation(data.conversation_history || []);

      } catch (e) {
        console.error("Error processing WebSocket message:", e, "Raw data:", event.data);
        document.getElementById('terminal').textContent = "Error processing data from server. See browser console.";
      }
    }

    function showTab(tabId) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none'); // Hide all
      
      // Find tab button that controls this tabId (more robust)
      const tabButton = Array.from(document.querySelectorAll('.tab')).find(
        (btn) => btn.getAttribute('onclick').includes(`'${tabId}'`)
      );
      if (tabButton) tabButton.classList.add('active');
      
      const activeTabContent = document.getElementById(tabId);
      if (activeTabContent) activeTabContent.style.display = 'block'; // Show active
    }
    // Initialize default tab
    showTab('traits-view');


    document.getElementById('theme-select').addEventListener('change', function() {
      document.body.className = this.value;
      // Redraw plots if they are visible, as colors might need to update
      if (document.getElementById('traits-view').style.display === 'block') {
        updateBarPlot(currentTraitData, {}, currentTraitColors); // Recalculate dominance inside if needed
      }
      if (document.getElementById('timeline-view').style.display === 'block') {
         let timelineTraitOrder = (currentTraitData.all_traits_pca_order && currentTraitData.all_traits_pca_order.length > 0) ? currentTraitData.all_traits_pca_order : currentTraitNames;
        updateTimeline(currentHistoryData, timelineTraitOrder, currentTraitColors);
      }
    });

    function interpret(traits, dominance, dominantTrait) {
      if (Object.keys(traits).length === 0) return "No trait data available.";
      let lines = Object.entries(traits).map(
        ([k, v]) => `${k.padEnd(20)} ${v.toFixed(2)} (${(dominance[k] || 0).toFixed(1)}%)`
      ).join('\n');
      let summary = `\nMost dominant trait: ${dominantTrait} (${(dominance[dominantTrait] || 0).toFixed(1)}%)\n`;
      summary += (dominance[dominantTrait] || 0) > 60
        ? "This trait is strongly defining the soul right now."
        : "The soul is currently balancing multiple influences.";
      return lines + "\n\n" + summary;
    }

    function updateBarPlot(traits, dominance, traitColors) {
      if (Object.keys(traits).length === 0) {
        Plotly.purge('barplot'); // Clear the plot if no data
        return;
      }
      let names = Object.keys(traits);
      let values = names.map(k => traits[k]);
      let doms = names.map(k => dominance[k] || 0);
      // Use traitColors for bars, fallback to accent colors if a color is missing
      let barColors = names.map(k => traitColors[k] || (doms[k] === Math.max(...doms) ? 'var(--accent)' : 'var(--accent2)'));

      let plotData = [{
        x: names, y: values, type: 'bar',
        marker: { color: barColors },
        text: doms.map(d => d.toFixed(1) + '%'),
        textposition: 'auto',
        hovertemplate: '%{x}: %{y:.2f} (%{text})<extra></extra>'
      }];
      let layout = {
        title: 'Current Soul Traits & Dominance',
        yaxis: { range: [0, 1.05], automargin: true }, // Increased range slightly
        xaxis: { automargin: true, tickangle: -45 },
        plot_bgcolor: getComputedStyle(document.body).getPropertyValue('--bg').trim(),
        paper_bgcolor: getComputedStyle(document.body).getPropertyValue('--bg').trim(),
        font: { color: getComputedStyle(document.body).getPropertyValue('--fg').trim() },
        margin: { t: 50, b: 100, l: 50, r: 30 } // Adjusted margins
      };
      Plotly.react('barplot', plotData, layout);
    }

    function updateTraitTable(traits, dominance, dominantTrait, traitColors) {
      let table = document.getElementById('trait-table');
      if (!table) return;
      let header = `<thead><tr><th>Trait</th><th>Value</th><th>Dominance (%)</th></tr></thead>`;
      let bodyRows = Object.keys(traits).map(k => {
        let dom = (dominance[k] || 0).toFixed(1);
        let rowClass = k === dominantTrait ? 'dominant' : '';
        // Apply color to trait name cell
        let traitNameStyle = traitColors[k] ? `style="color: ${traitColors[k]}; font-weight: bold;"` : '';
        return `<tr class="${rowClass}"><td ${traitNameStyle}>${k}</td><td>${traits[k].toFixed(2)}</td><td>${dom}</td></tr>`;
      }).join('');
      table.innerHTML = header + `<tbody>${bodyRows}</tbody>`;
    }

    function updateDiscoveredTable(traitFirstSeen, currentTraits, currentStep, traitColors) {
      let table = document.getElementById('discovered-table');
      if (!table) return;
      let header = `<thead><tr><th>Trait</th><th>First Seen (Step)</th><th>Age (Steps)</th><th>Current Value</th></tr></thead>`;
      // Sort traits by when they were first seen
      let allSeenTraits = Object.keys(traitFirstSeen).sort((a, b) => traitFirstSeen[a] - traitFirstSeen[b]);
      
      let bodyRows = allSeenTraits.map(k => {
        let val = currentTraits[k] !== undefined ? currentTraits[k].toFixed(2) : '— (Removed)';
        let age = currentTraits[k] !== undefined ? currentStep - traitFirstSeen[k] : '—';
        // Apply color to trait name cell
        let traitNameStyle = traitColors[k] ? `style="color: ${traitColors[k]}; font-weight: bold;"` : '';
        return `<tr><td ${traitNameStyle}>${k}</td><td>${traitFirstSeen[k]}</td><td>${age}</td><td>${val}</td></tr>`;
      }).join('');
      table.innerHTML = header + `<tbody>${bodyRows}</tbody>`;
    }
    
    function updateTimeline(historyData, timelineTraitOrder, traitColors) {
      let chartElement = document.getElementById('timeline-chart');
      if (historyData.length === 0 || timelineTraitOrder.length === 0) {
        Plotly.purge(chartElement); // Clear plot if no data
        return;
      }

      // Ensure z data is rectangular and handles missing traits correctly
      let z_data = historyData.map(snap => 
        timelineTraitOrder.map(traitName => snap[traitName] !== undefined ? snap[traitName] : null)
      );

      let plotData = [{
        z: z_data,
        x: timelineTraitOrder, // Trait names on x-axis
        y: Array.from({length: historyData.length}, (_, i) => i), // Steps on y-axis
        type: 'heatmap',
        colorscale: 'Viridis', // Example colorscale
        reversescale: true,
        colorbar: { title: 'Trait Value', titleside: 'right', tickvals: [0, 0.25, 0.5, 0.75, 1], ticktext: ['0.0', '0.25', '0.5', '0.75', '1.0']},
        hoverongaps: false,
        xgap: 1, ygap: 1 // Add gaps between cells
      }];
      let layout = {
        title: 'Trait Value Timeline (Heatmap)',
        xaxis: { title: 'Trait', automargin: true, tickangle: -45 },
        yaxis: { title: 'Simulation Step', autorange: 'reversed', automargin: true },
        plot_bgcolor: getComputedStyle(document.body).getPropertyValue('--bg').trim(),
        paper_bgcolor: getComputedStyle(document.body).getPropertyValue('--bg').trim(),
        font: { color: getComputedStyle(document.body).getPropertyValue('--fg').trim() },
        margin: { t: 50, b: 100, l: 60, r: 30 } // Adjusted margins
      };
      Plotly.react(chartElement, plotData, layout);
    }

    function updateConversation(conversationLog) {
      let div = document.getElementById('conversation-log');
      if (!div) return;
      div.innerHTML = conversationLog.map(msg => {
        let speakerClass = (msg.speaker || 'unknown').toLowerCase().replace(/[\s\(\)]/g, '-'); // Sanitize speaker for class
        if (speakerClass.startsWith('ai-')) speakerClass = speakerClass.replace('ai-','ai'); // Normalize
        return `
        <div class="msg ${speakerClass}">
          <div class="meta">${msg.speaker} &middot; ${new Date(msg.timestamp).toLocaleString()}</div>
          <div class="text">${(msg.text || "").replace(/\n/g, '<br>')}</div>
        </div>`;
      }).join('');
      div.scrollTop = div.scrollHeight; // Scroll to bottom
    }

    document.getElementById('set-prompt-btn').onclick = async function() {
      const customPrompt = document.getElementById('prompt-box').value;
      const statusSpan = document.getElementById('prompt-status');
      statusSpan.textContent = 'Setting custom prompt...';
      statusSpan.style.color = 'var(--accent)';
      try {
        const response = await fetch('/set_prompt', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: customPrompt })
        });
        const responseData = await response.json();
        if (response.ok && responseData.status === 'ok') {
          statusSpan.textContent = responseData.prompt_set_to === "default" ? 'Prompt cleared (using default).' : 'Custom prompt set!';
          statusSpan.style.color = 'green';
        } else {
          statusSpan.textContent = `Error: ${responseData.message || 'Failed to set prompt.'}`;
          statusSpan.style.color = 'red';
        }
      } catch (e) {
        statusSpan.textContent = 'Error: Failed to send prompt to server.';
        statusSpan.style.color = 'red';
        console.error("Fetch error for /set_prompt:", e);
      }
    };
  </script>
</body>
</html>