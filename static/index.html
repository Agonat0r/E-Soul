<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Soul Trait Evolution (Live)</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root {
      --bg: #f6f8fa; --fg: #222; --panel: #fff; --panel-alt: #e9eef3;
      --accent: #4a90e2; --accent2: #b2c7e1; --table-header: #e9eef3; --table-row: #f6f8fa;
      --dominant: #e3f2fd; 
      --msg-ai-soul: #e3f2fd; /* Main AI analysis/reflection */
      --msg-system-evolution: #d1c4e9; /* For stage transition messages */
      --msg-meta: #7b8a99;
    }
    body.soft-blue {
      --bg: #eaf3fb; --fg: #223344; --panel: #f7fbff; --panel-alt: #dbeafe;
      --accent: #4a90e2; --accent2: #b2c7e1; --table-header: #dbeafe; --table-row: #eaf3fb;
      --dominant: #b3e5fc; --msg-ai-soul: #b3e5fc; --msg-system-evolution: #d1c4e9; --msg-meta: #607d8b;
    }
    body.solarized {
      --bg: #fdf6e3; --fg: #657b83; --panel: #f5eecb; --panel-alt: #eee8d5;
      --accent: #268bd2; --accent2: #b58900; --table-header: #eee8d5; --table-row: #fdf6e3;
      --dominant: #b58900; --msg-ai-soul: #eee8d5; --msg-system-evolution: #cebddb; --msg-meta: #657b83;
    }
    body.pastel {
      --bg: #f8f7fa; --fg: #4b3f72; --panel: #f3e8ff; --panel-alt: #e0c3fc;
      --accent: #a3cef1; --accent2: #f9c6c9; --table-header: #e0c3fc; --table-row: #f8f7fa;
      --dominant: #f9c6c9; --msg-ai-soul: #e0c3fc; --msg-system-evolution: #d1c4e9; --msg-meta: #4b3f72;
    }
    body { background: var(--bg); color: var(--fg); font-family: sans-serif; transition: background 0.3s, color 0.3s; margin: 0; padding: 20px; }
    .tabs { display: flex; margin-bottom: 20px; flex-wrap: wrap; }
    .tab { padding: 12px 28px; background: var(--panel-alt); color: var(--fg); border-radius: 8px 8px 0 0; margin-right: 6px; margin-bottom: 6px; cursor: pointer; font-weight: 500; border: none; outline: none; transition: background 0.2s, color 0.2s; }
    .tab.active { background: var(--panel); color: var(--accent); }
    .tab-content { display: none; padding: 15px; background: var(--panel); border-radius: 0 8px 8px 8px; box-shadow: 0 2px 8px #0002; }
    .tab-content.active { display: block; }
    #barplot, #timeline-chart { width:100%; max-width:900px; height:350px; margin-bottom: 30px; }
    #trait-table, #discovered-table { background: var(--panel); color: var(--fg); font-family: 'Courier New', Courier, monospace; border-radius: 8px; max-width: 900px; margin: 0 auto 30px auto; border-collapse: collapse; width: 100%; box-shadow: 0 2px 8px #0002; }
    #trait-table th, #trait-table td, #discovered-table th, #discovered-table td { border: 1px solid var(--panel-alt); padding: 8px 12px; text-align: left; }
    #trait-table th, #discovered-table th { background: var(--table-header); color: var(--accent); font-weight: bold; }
    #trait-table tr.dominant { background: var(--dominant); }
    #terminal { background: var(--panel); color: var(--fg); font-family: 'Courier New', Courier, monospace; padding: 20px; border-radius: 8px; min-height: 120px; max-width: 900px; margin: 0 auto; white-space: pre-wrap; word-break: break-word; overflow-wrap: break-word; box-shadow: 0 2px 8px #0002; border: 1px solid var(--panel-alt); }
    #conversation-display-area, #theories-display-area { 
        background: var(--panel); color: var(--fg); font-family: 'Courier New', Courier, monospace;
        border-radius: 8px; max-width: 900px; margin: 0 auto 30px auto;
        padding: 20px; min-height: 150px; box-shadow: 0 2px 8px #0002;
        border: 1px solid var(--panel-alt); max-height: 400px; overflow-y: auto;
    }
    .conversation-nav { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; max-width: 900px; margin-left: auto; margin-right: auto;}
    .conversation-nav button { padding: 8px 15px; }
    #msg-counter { font-weight: bold; color: var(--accent); }
    .msg { margin-bottom: 12px; padding: 10px 16px; border-radius: 12px; background: var(--panel-alt); color: var(--fg); max-width: 95%; box-shadow: 0 1px 3px rgba(0,0,0,0.1); line-height: 1.4; }
    .msg.ai-soul, .msg.ai-soul-analysis, .msg.ai-soul-self-reply  { background: var(--msg-ai-soul); color: var(--fg); align-self: flex-start; border-left: 3px solid var(--accent); }
    .msg.system-evolution { background: var(--msg-system-evolution); color: var(--fg); align-self: center; text-align: center; font-style: italic; border-left: 3px solid #805ad5; max-width: 100%;}
    .msg .meta { font-size: 0.8em; color: var(--msg-meta); margin-bottom: 5px; }
    .msg .text { white-space: pre-wrap; }
    .theme-select, input[type="password"], input[type="text"], textarea, button { margin-bottom:12px;padding:10px;border-radius:6px;border:1px solid var(--panel-alt); background:var(--panel);color:var(--fg); font-size: 1em; box-sizing: border-box; }
    button { background:var(--accent);color:#fff;border:none;cursor:pointer; }
    input[type="password"], input[type="text"], textarea { width: calc(100% - 22px); }
    .container { max-width: 900px; margin: 0 auto; }
    .theory-entry { margin-bottom: 15px; padding: 15px; border-radius:8px; background: var(--panel-alt); border-left: 3px solid var(--accent2); }
    .theory-entry:last-child { border-bottom: none; }
    .theory-meta { font-size: 0.8em; color: var(--msg-meta); margin-bottom: 8px; }
    .theory-text { line-height: 1.5; }
    #evolution-info { text-align: center; margin-bottom: 15px; padding: 10px; background-color: var(--panel-alt); border-radius: 8px;}
    #evolutionary-stage-display { color: var(--accent); font-weight:bold; font-size: 1.2em; }
    #evolutionary-stage-description { font-style: italic; color: var(--fg); font-size: 0.9em; margin-top: 5px;}

  </style>
</head>
<body>
  <div id="api-key-setup" class="container" style="margin-top:40px;margin-bottom:30px;padding:30px;background:var(--panel);border-radius:10px;box-shadow:0 2px 8px #0002;">
    <h2>Enter Gemini API Key to Begin</h2>
    <label for="gemini-key"><b>Gemini API Key:</b></label><br>
    <input id="gemini-key" type="password" placeholder="Your Gemini API Key"><br>
    <button id="set-keys-btn">Set API Key & Start Simulation</button>
    <span id="api-key-status" style="margin-left:20px; font-weight: bold;"></span>
  </div>

  <div id="main-dashboard" style="display:none;">
    <div class="container"><h1>Soul Trait Evolution (Live)</h1></div>
    <div id="evolution-info" class="container">
      <h3>Current Evolutionary Stage: <span id="evolutionary-stage-display">Initializing...</span></h3>
      <p id="evolutionary-stage-description"></p>
    </div>
    <div class="tabs container">
      <button class="tab active" onclick="showTab('traits-view')">Traits</button>
      <button class="tab" onclick="showTab('timeline-view')">Timeline</button>
      <button class="tab" onclick="showTab('conversation-view')">Log</button>
      <button class="tab" onclick="showTab('theories-view')">Theories</button>
      <button class="tab" onclick="showTab('customization-view')">Settings</button>
      <button class="tab" onclick="showTab('bodyenv')">Body & Environment</button>
    </div>

    <div id="traits-view" class="tab-content active container">
      <div id="barplot"></div>
      <h3 style="margin-top: 30px;">Current Trait Values</h3><table id="trait-table"></table>
      <h3 style="margin-top: 30px;">Discovered Traits</h3><table id="discovered-table"></table>
      <h3 style="margin-top: 30px;">AI's Brief Interpretation</h3><div id="terminal">Waiting for data...</div>
    </div>
    <div id="timeline-view" class="tab-content container"><div id="timeline-chart"></div></div>
    
    <div id="conversation-view" class="tab-content container">
      <div class="conversation-nav">
        <button id="prev-msg-btn" title="Previous Message">&larr; Prev</button>
        <span id="msg-counter">Message 0 of 0</span>
        <button id="next-msg-btn" title="Next Message">Next &rarr;</button>
      </div>
      <div id="conversation-display-area" style="min-height: 100px;">Select a message to view.</div>
    </div>

    <div id="theories-view" class="tab-content container">
        <h3>AI's Evolving Theories</h3>
        <div id="theories-display-area">Waiting for theories...</div>
    </div>

    <div id="customization-view" class="tab-content container">
      <label for="theme-select"><b>Choose a theme:</b></label>
      <select id="theme-select" class="theme-select">
        <option value="">Light (Default)</option><option value="soft-blue">Soft Blue</option>
        <option value="solarized">Solarized</option><option value="pastel">Pastel</option>
      </select>
      <hr style="margin: 30px 0;">
      <label for="prompt-box"><b>Custom Base Prompt for AI (Optional):</b></label><br>
      <textarea id="prompt-box" rows="4" placeholder="Enter your custom base prompt for the AI's analytical statements here..."></textarea><br>
      <button id="set-prompt-btn">Set Custom Prompt</button>
      <span id="prompt-status" style="margin-left: 20px;"></span>
    </div>

    <div id="bodyenv" class="tab-content" style="display:none;">
      <div style="display:flex;gap:30px;align-items:flex-start;">
        <div style="width:220px;">
          <input id="module-search" type="text" placeholder="Search modules..." style="width:100%;margin-bottom:10px;padding:6px;border-radius:6px;border:1px solid var(--panel-alt);">
          <div id="module-library" style="height:500px;overflow-y:auto;border:1px solid var(--panel-alt);border-radius:8px;background:var(--panel);padding:10px;"></div>
        </div>
        <div style="flex:1;min-width:400px;">
          <!-- Prototyping Section -->
          <div id="prototyping-section" style="margin-bottom:30px;">
            <h3>Prototyping Canvas</h3>
            <label for="mcu-board-select"><b>Select Microcontroller:</b></label>
            <select id="mcu-board-select" style="margin-left:10px;padding:6px 12px;border-radius:6px;">
              <option value="arduino">Arduino Uno</option>
              <option value="esp32">ESP32 DevKit</option>
              <option value="stm32">STM32 Blue Pill</option>
              <option value="pico">Raspberry Pi Pico</option>
            </select>
            <div id="proto-canvas-container" style="position:relative;width:100%;height:350px;background:var(--panel-alt);border:2px solid var(--accent2);border-radius:10px;margin-top:15px;overflow:hidden;">
              <svg id="proto-wires" width="100%" height="350" style="position:absolute;left:0;top:0;z-index:1;"></svg>
              <div id="proto-mcu" style="position:absolute;left:40px;top:80px;z-index:2;"></div>
              <div id="proto-modules" style="position:absolute;left:200px;top:20px;z-index:2;"></div>
            </div>
            <div id="proto-connection-data" style="margin-top:10px;background:var(--panel);padding:10px;border-radius:6px;min-height:40px;font-family:monospace;font-size:0.95em;"></div>
          </div>
          <!-- Existing robot canvas and schematic upload below -->
          <div id="robot-canvas" style="width:100%;height:400px;border:2px dashed var(--accent2);border-radius:10px;background:var(--panel-alt);position:relative;overflow:hidden;"></div>
          <button id="toggle-3d-btn" style="margin-top:10px;padding:8px 18px;border-radius:6px;background:var(--accent);color:#fff;border:none;cursor:pointer;">Switch to 3D View (Coming Soon)</button>
          <div style="margin-top:20px;">
            <label><b>Upload Schematic:</b></label>
            <input type="file" id="schematic-upload" accept="image/*,.json,.txt,.netlist">
            <button id="analyze-schematic-btn" style="padding:6px 14px;border-radius:6px;background:var(--accent2);color:var(--fg);border:none;cursor:pointer;">Analyze</button>
            <div id="schematic-analysis" style="margin-top:10px;background:var(--panel);padding:10px;border-radius:6px;min-height:60px;"></div>
          </div>
          <hr style="margin:30px 0;">
          <div id="mcu-section">
            <h3>Microcontroller Integration</h3>
            <button id="scan-mcu-btn" style="padding:8px 18px;border-radius:6px;background:var(--accent);color:#fff;border:none;cursor:pointer;">Scan for Microcontrollers</button>
            <select id="mcu-select" style="margin-left:10px;padding:6px 12px;border-radius:6px;"></select>
            <div id="mcu-scan-status" style="margin-top:10px;color:var(--accent);"></div>
            <div style="margin-top:18px;">
              <label><b>Paste Code (Arduino/ESP32) or select firmware file:</b></label><br>
              <textarea id="firmware-code" rows="8" style="width:100%;margin-bottom:10px;border-radius:6px;padding:10px;"></textarea><br>
              <input type="file" id="firmware-file" accept=".bin,.hex,.uf2">
              <button id="upload-firmware-btn" style="margin-top:10px;padding:8px 18px;border-radius:6px;background:var(--accent2);color:var(--fg);border:none;cursor:pointer;">Upload Firmware</button>
              <div id="firmware-upload-status" style="margin-top:10px;background:var(--panel);padding:10px;border-radius:6px;min-height:60px;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let ws; 
    let currentTraitData = {}, currentHistoryData = [], currentTraitNames = [], currentTraitFirstSeen = {}, currentTraitColors = {};
    let fullConversationHistory = [];
    let currentConversationIndex = -1;
    let evolvingTheories = [];
    let currentStepForUI = 0; // To keep track of step for UI elements if needed
    let detectedMCUs = [];

    document.getElementById('set-keys-btn').onclick = async function() { 
        const geminiKey = document.getElementById('gemini-key').value.trim();
        const statusSpan = document.getElementById('api-key-status');
        if (!geminiKey) {
            statusSpan.textContent = 'Error: Gemini API Key is required.'; statusSpan.style.color = 'red'; return;
        }
        statusSpan.textContent = 'Validating API Key...'; statusSpan.style.color = 'var(--accent)';
        try {
            const response = await fetch('/set_api_keys', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ gemini_api_key: geminiKey }) 
            });
            const responseData = await response.json();
            if (response.ok && responseData.status === 'ok') {
            statusSpan.textContent = responseData.message || 'Gemini API Key Accepted! Starting...'; statusSpan.style.color = 'green';
            document.getElementById('api-key-setup').style.display = 'none';
            document.getElementById('main-dashboard').style.display = 'block';
            showTab('traits-view'); 
            connectWebSocket();
            } else {
            let errorMsg = 'Error setting API key: ';
            if (responseData.errors && responseData.errors.gemini_api_key) errorMsg += responseData.errors.gemini_api_key;
            else if (responseData.message) errorMsg += responseData.message;
            else errorMsg += `Server responded with status ${response.status}. Check server logs for details.`;
            statusSpan.textContent = errorMsg; statusSpan.style.color = 'red'; console.error("API Key validation failed:", responseData);
            }
        } catch (e) {
            statusSpan.textContent = 'Error: Failed to communicate with server to set API key. Is the server running?'; statusSpan.style.color = 'red'; console.error("Fetch error for /set_api_keys:", e);
        }
    };

    function connectWebSocket() { 
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        ws = new WebSocket(`${wsProtocol}//${window.location.host}/ws`);
        ws.onopen = () => { console.log('WS connected!'); document.getElementById('terminal').textContent = 'Connection established. Waiting for initial soul data...';};
        ws.onmessage = ws_onmessage_handler;
        ws.onclose = (event) => { 
            console.log('WS disconnected:', event.reason, event.code); 
            const term = document.getElementById('terminal');
            if(term) term.textContent = `WS disconnected. Code: ${event.code}. ${event.reason ? `Reason: ${event.reason}. ` : ''}Attempting to reconnect...`; 
            if (document.getElementById('api-key-setup').style.display === 'none') {
                 setTimeout(connectWebSocket, 7000);
            }
        };
        ws.onerror = (error) => { console.error('WS error:', error); document.getElementById('terminal').textContent = 'WebSocket connection error. Check console and server logs.';};
    }

    function ws_onmessage_handler(event) {
      try {
        let data = JSON.parse(event.data); 
        // Fallback for console log if data.step is undefined for some reason
        console.log("Received data for step:", data.step !== undefined ? data.step : currentStepForUI, data);

        currentTraitData = data.traits || {}; 
        currentHistoryData = data.history || [];
        currentTraitNames = data.trait_names || []; 
        currentTraitFirstSeen = data.trait_first_seen || {};
        currentTraitColors = data.trait_colors || {};
        currentStepForUI = data.step !== undefined ? data.step : currentStepForUI; // Update current step

        const newConversationHistory = data.conversation_history || [];
        if (newConversationHistory.length > 0 && (newConversationHistory.length !== fullConversationHistory.length || 
            JSON.stringify(newConversationHistory[newConversationHistory.length-1]) !== JSON.stringify(fullConversationHistory[fullConversationHistory.length-1]))) {
            fullConversationHistory = newConversationHistory;
            // Only auto-set to last message if it's a new message and we're not already deep in history
            if (currentConversationIndex < fullConversationHistory.length - 2 || currentConversationIndex === -1) {
                 currentConversationIndex = fullConversationHistory.length - 1; 
            }
        }
        displayConversationMessage(); 
        
        evolvingTheories = data.evolving_theories || [];
        updateTheoriesDisplay();

        const stageDisplay = document.getElementById('evolutionary-stage-display');
        const stageDescriptionDisplay = document.getElementById('evolutionary-stage-description');
        if (data.current_evolutionary_stage && stageDisplay) {
            stageDisplay.textContent = data.current_evolutionary_stage;
        }
        if (data.current_stage_description && stageDescriptionDisplay) {
            stageDescriptionDisplay.textContent = data.current_stage_description;
        }

        let sum = Object.values(currentTraitData).reduce((a, b) => a + b, 0) || 1;
        let dominance = {}; Object.keys(currentTraitData).forEach(k => dominance[k] = (currentTraitData[k] / sum) * 100);
        let dominantTrait = Object.keys(dominance).length > 0 ? Object.keys(dominance).reduce((a,b)=>dominance[a]>dominance[b]?a:b) : 'N/A';
        
        updateBarPlot(currentTraitData, dominance, currentTraitColors);
        updateTraitTable(currentTraitData, dominance, dominantTrait, currentTraitColors);
        updateDiscoveredTable(currentTraitFirstSeen, currentTraitData, currentStepForUI, currentTraitColors);
        let timelineTraitOrder = (data.all_traits_pca_order && data.all_traits_pca_order.length > 0) ? data.all_traits_pca_order : currentTraitNames;
        updateTimeline(currentHistoryData, timelineTraitOrder); // Removed traitColors from timeline for now
        document.getElementById('terminal').textContent = interpret(currentTraitData, dominance, dominantTrait);
      } catch (e) { console.error("Error processing WS msg:", e, "Raw:", event.data); document.getElementById('terminal').textContent = "Error processing data. See console."; }
    }

    function showTab(tabId) { 
        document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
        const tabButton = Array.from(document.querySelectorAll('.tabs .tab')).find(btn => btn.getAttribute('onclick').includes(`'${tabId}'`));
        if (tabButton) tabButton.classList.add('active');
        const activeTabContent = document.getElementById(tabId);
        if (activeTabContent) activeTabContent.style.display = 'block';
    }
    
    document.getElementById('theme-select').addEventListener('change', function() { 
        document.body.className = this.value;
        if (typeof Plotly !== 'undefined' && document.getElementById('main-dashboard').style.display !== 'none') {
            // Re-trigger a general UI update which will re-render plots with new theme colors
             ws_onmessage_handler({data: JSON.stringify({ 
                traits: currentTraitData, history: currentHistoryData, trait_names: currentTraitNames,
                trait_first_seen: currentTraitFirstSeen, trait_colors: currentTraitColors,
                conversation_history: fullConversationHistory, evolving_theories: evolvingTheories,
                step: currentStepForUI, 
                all_traits_pca_order: currentTraitData.all_traits_pca_order || currentTraitNames,
                current_evolutionary_stage: document.getElementById('evolutionary-stage-display').textContent,
                current_stage_description: document.getElementById('evolutionary-stage-description').textContent
            })});
        }
    });

    function interpret(traits, dominance, dominantTrait) { 
      if (Object.keys(traits).length === 0) return "No trait data available at this moment.";
      let lines = Object.entries(traits).map(([k,v])=>`${k.padEnd(25)} ${Number(v).toFixed(3)} (${(dominance[k]||0).toFixed(1)}%)`).join('\n');
      let summary = `\nDominant Trait: ${dominantTrait} (${(dominance[dominantTrait]||0).toFixed(1)}%)\n`;
      summary += (dominance[dominantTrait]||0)>60?"This trait is strongly defining the soul's current state.":"The soul's state is influenced by a balance of multiple traits.";
      return `Step: ${currentStepForUI}\n` + lines + "\n\n" + summary;
    }

    function updateBarPlot(traits, dominance, traitColors) { 
      let chartEl = document.getElementById('barplot');
      if (Object.keys(traits).length === 0) { Plotly.purge(chartEl); return; }
      let names = Object.keys(traits); let values = names.map(k => traits[k]);
      let doms = names.map(k => dominance[k] || 0);
      let barColors = names.map(k => traitColors[k] || (doms[k] === Math.max(...doms) ? getComputedStyle(document.body).getPropertyValue('--accent').trim() : getComputedStyle(document.body).getPropertyValue('--accent2').trim()));
      let plotData = [{ x: names, y: values, type: 'bar', marker: {color: barColors}, text: doms.map(d => d.toFixed(1)+'%'), textposition: 'auto', hovertemplate: '<b>%{x}</b><br>Value: %{y:.3f}<br>Dominance: %{text}<extra></extra>'}];
      let layout = { title: 'Current Soul Traits & Dominance', yaxis: {range:[0,1.05],automargin:true, title: 'Value'}, xaxis:{automargin:true,tickangle: names.length > 6 ? -45 : 0}, plot_bgcolor:getComputedStyle(document.body).getPropertyValue('--bg').trim(), paper_bgcolor:getComputedStyle(document.body).getPropertyValue('--bg').trim(), font:{color:getComputedStyle(document.body).getPropertyValue('--fg').trim()}, margin:{t:50,b:120,l:60,r:30}};
      Plotly.react(chartEl, plotData, layout);
    }

    function updateTraitTable(traits, dominance, dominantTrait, traitColors) { 
      let table = document.getElementById('trait-table'); if (!table) return;
      let header = `<thead><tr><th>Trait</th><th>Value</th><th>Dominance (%)</th></tr></thead>`;
      let bodyRows = Object.keys(traits).sort().map(k => { // Sort trait names alphabetically
        let dom = (dominance[k] || 0).toFixed(1); let rowClass = k === dominantTrait ? 'dominant' : '';
        let traitNameStyle = traitColors[k] ? `style="color: ${traitColors[k]}; font-weight: bold;"` : '';
        return `<tr class="${rowClass}"><td ${traitNameStyle}>${k}</td><td>${Number(traits[k]).toFixed(3)}</td><td>${dom}</td></tr>`;}).join('');
      table.innerHTML = header + `<tbody>${bodyRows}</tbody>`;
    }

    function updateDiscoveredTable(traitFirstSeenData, currentTraitsData, step, traitColors) { 
      let table = document.getElementById('discovered-table'); if (!table) return;
      let header = `<thead><tr><th>Trait</th><th>First Seen (Step)</th><th>Age (Steps)</th><th>Current Value</th></tr></thead>`;
      let allSeenTraits = Object.keys(traitFirstSeenData).sort((a,b)=>traitFirstSeenData[a]-traitFirstSeenData[b]);
      let bodyRows = allSeenTraits.map(k => {
        let val = currentTraitsData[k] !== undefined ? Number(currentTraitsData[k]).toFixed(3) : 'â€” (Vanished)';
        let age = currentTraitsData[k] !== undefined ? step - traitFirstSeenData[k] : 'â€”';
        let traitNameStyle = traitColors[k] ? `style="color: ${traitColors[k]}; font-weight: bold;"` : '';
        return `<tr><td ${traitNameStyle}>${k}</td><td>${traitFirstSeenData[k]}</td><td>${age}</td><td>${val}</td></tr>`;}).join('');
      table.innerHTML = header + `<tbody>${bodyRows}</tbody>`;
    }

    function updateTimeline(historyData, timelineTraitOrder) { 
      let chartElement = document.getElementById('timeline-chart');
      if (historyData.length < 2 || timelineTraitOrder.length === 0) { Plotly.purge(chartElement); if(chartElement) chartElement.innerHTML = '<p style="text-align:center;padding-top:50px;color:var(--msg-meta);">Not enough history for timeline yet.</p>'; return; }
      let z_data = historyData.map(snap => timelineTraitOrder.map(tn => snap[tn]!==undefined?snap[tn]:null));
      let plotData = [{ z: z_data, x: timelineTraitOrder, y: Array.from({length:historyData.length},(_,i)=> currentStepForUI - historyData.length + 1 + i), type:'heatmap', colorscale:'Viridis', reversescale:true, colorbar:{title:'Value',titleside:'right',tickvals:[0,0.25,0.5,0.75,1],ticktext:['0.0','0.25','0.5','0.75','1.0']}, hoverongaps:false, xgap:1,ygap:1}];
      let layout = { title: 'Trait Value Timeline', xaxis:{title:'Trait',automargin:true,tickangle: timelineTraitOrder.length > 6 ? -45 : 0}, yaxis:{title:'Simulation Step',autorange:'reversed',automargin:true}, plot_bgcolor:getComputedStyle(document.body).getPropertyValue('--bg').trim(), paper_bgcolor:getComputedStyle(document.body).getPropertyValue('--bg').trim(), font:{color:getComputedStyle(document.body).getPropertyValue('--fg').trim()}, margin:{t:50,b:120,l:70,r:30}};
      Plotly.react(chartElement, plotData, layout);
    }

    document.getElementById('prev-msg-btn').onclick = function() {
      if (fullConversationHistory.length > 0 && currentConversationIndex > 0) {
        currentConversationIndex--; displayConversationMessage();
      }
    };
    document.getElementById('next-msg-btn').onclick = function() {
      if (fullConversationHistory.length > 0 && currentConversationIndex < fullConversationHistory.length - 1) {
        currentConversationIndex++; displayConversationMessage();
      }
    };

    function displayConversationMessage() {
      const displayArea = document.getElementById('conversation-display-area');
      const counter = document.getElementById('msg-counter');
      if (!displayArea || !counter) return;
      if (fullConversationHistory.length === 0) {
        displayArea.innerHTML = '<p style="text-align:center; color: var(--msg-meta);">No conversation messages yet.</p>';
        counter.textContent = `Message 0 of 0`;
        document.getElementById('prev-msg-btn').disabled = true;
        document.getElementById('next-msg-btn').disabled = true;
        return;
      }
      if (currentConversationIndex < 0 || currentConversationIndex >= fullConversationHistory.length) {
          currentConversationIndex = fullConversationHistory.length -1; // Default to last if out of bounds
      }
      const msg = fullConversationHistory[currentConversationIndex];
      let speakerClass = (msg.speaker || 'unknown').toLowerCase().replace(/[\s\(\)]/g, '-');
      if(msg.type === "evolution") speakerClass = "system-evolution";
      else if (speakerClass.startsWith('ai-soul-') && speakerClass !== 'ai-soul-self-reply') speakerClass = 'ai-soul';

      displayArea.innerHTML = `
        <div class="msg ${speakerClass}">
          <div class="meta">${msg.speaker} (Step: ${msg.step || currentStepForUI}) &middot; ${new Date(msg.timestamp).toLocaleString()}</div>
          <div class="text">${(msg.text || "Error: Empty message content").replace(/\n/g, '<br>')}</div>
        </div>`;
      counter.textContent = `Message ${currentConversationIndex + 1} of ${fullConversationHistory.length}`;
      document.getElementById('prev-msg-btn').disabled = (currentConversationIndex <= 0);
      document.getElementById('next-msg-btn').disabled = (currentConversationIndex >= fullConversationHistory.length - 1);
      displayArea.scrollTop = 0; // Scroll to top of the message
    }
    
    function updateTheoriesDisplay() {
        const displayArea = document.getElementById('theories-display-area');
        if (!displayArea) return;
        if (evolvingTheories.length === 0) {
            displayArea.innerHTML = '<p style="text-align:center; color: var(--msg-meta);">The AI has not yet formed any theories.</p>';
            return;
        }
        displayArea.innerHTML = evolvingTheories.slice().reverse().map((theory, index) => `
            <div class="theory-entry">
                <div class="theory-meta">Theory Version #${evolvingTheories.length - index} (Generated at Step: ${theory.step}, Stage: ${theory.stage || 'N/A'}) &middot; ${new Date(theory.timestamp).toLocaleString()}</div>
                <div class="theory-text">${(theory.text || "Error: Empty theory content").replace(/\n/g, '<br>')}</div>
            </div>
        `).join('');
        displayArea.scrollTop = 0; // Show newest theory first
    }

    document.getElementById('set-prompt-btn').onclick = async function() { 
      const customPrompt = document.getElementById('prompt-box').value;
      const statusSpan = document.getElementById('prompt-status'); statusSpan.textContent = 'Setting...'; statusSpan.style.color = 'var(--accent)';
      try {
        const response = await fetch('/set_prompt', { method: 'POST', headers: {'Content-Type':'application/json'}, body:JSON.stringify({prompt:customPrompt})});
        const responseData = await response.json();
        if (response.ok && responseData.status === 'ok') { statusSpan.textContent = responseData.prompt_set_to==="Custom"?'Custom base prompt successfully set!':'Custom prompt cleared. Using default system prompt.'; statusSpan.style.color = 'green';}
        else { statusSpan.textContent = `Error: ${responseData.message||'Failed to set prompt.'}`; statusSpan.style.color = 'red';}
      } catch (e) { statusSpan.textContent = 'Error: Failed to send prompt to server.'; statusSpan.style.color = 'red'; console.error("Fetch error for /set_prompt:", e);}
    };

    const MODULES = [
      {name:'Camera',icon:'ðŸ“·',desc:'Visual sensor for perception.'},
      {name:'Microphone',icon:'ðŸŽ¤',desc:'Audio sensor for sound input.'},
      {name:'Speaker',icon:'ðŸ”Š',desc:'Audio output for communication.'},
      {name:'IR Sensor',icon:'ðŸŒ¡ï¸',desc:'Infrared sensor for proximity or heat.'},
      {name:'Ultrasonic Sensor',icon:'ðŸ“¡',desc:'Distance measurement.'},
      {name:'Servo Motor',icon:'ðŸ”©',desc:'Precise rotational actuator.'},
      {name:'DC Motor',icon:'âš™ï¸',desc:'General purpose motor.'},
      {name:'Stepper Motor',icon:'ðŸ”ƒ',desc:'Precise step-based motor.'},
      {name:'LIDAR',icon:'ðŸ›°ï¸',desc:'Laser-based distance sensor.'},
      {name:'IMU',icon:'ðŸ§­',desc:'Inertial measurement unit.'},
      {name:'GPS',icon:'ðŸ“',desc:'Global positioning system.'},
      {name:'Temperature Sensor',icon:'ðŸŒ¡ï¸',desc:'Measures temperature.'},
      {name:'Humidity Sensor',icon:'ðŸ’§',desc:'Measures humidity.'},
      {name:'Pressure Sensor',icon:'â²ï¸',desc:'Measures pressure.'},
      {name:'Light Sensor',icon:'ðŸ’¡',desc:'Detects light intensity.'},
      {name:'Touch Sensor',icon:'ðŸ¤š',desc:'Detects touch/contact.'},
      {name:'Proximity Sensor',icon:'ðŸ“¶',desc:'Detects nearby objects.'},
      {name:'Accelerometer',icon:'ðŸŽï¸',desc:'Measures acceleration.'},
      {name:'Gyroscope',icon:'ðŸŒ€',desc:'Measures rotation.'},
      {name:'Magnetometer',icon:'ðŸ§²',desc:'Measures magnetic field.'},
      {name:'Gas Sensor',icon:'ðŸ«§',desc:'Detects gases.'},
      {name:'Flame Sensor',icon:'ðŸ”¥',desc:'Detects flame.'},
      {name:'Vibration Sensor',icon:'ðŸ’¥',desc:'Detects vibration.'},
      {name:'Force Sensor',icon:'ðŸ¦¾',desc:'Measures force/pressure.'},
      {name:'Color Sensor',icon:'ðŸŽ¨',desc:'Detects color.'},
      {name:'RFID',icon:'ðŸ“›',desc:'Radio-frequency ID.'},
      {name:'Bluetooth',icon:'ðŸ“¶',desc:'Wireless comm.'},
      {name:'WiFi',icon:'ðŸ“¡',desc:'Wireless comm.'},
      {name:'Zigbee',icon:'ðŸ“¶',desc:'Wireless comm.'},
      {name:'LoRa',icon:'ðŸ“¶',desc:'Long-range wireless.'},
      {name:'Relay',icon:'ðŸ”Œ',desc:'Switches circuits.'},
      {name:'Buzzer',icon:'ðŸ””',desc:'Makes sound.'},
      {name:'LED',icon:'ðŸ’¡',desc:'Light emitting diode.'},
      {name:'LCD Display',icon:'ðŸ–¥ï¸',desc:'Text/graphics display.'},
      {name:'OLED Display',icon:'ðŸ–¥ï¸',desc:'High-contrast display.'},
      {name:'E-Paper Display',icon:'ðŸ“„',desc:'Low-power display.'},
      {name:'Keypad',icon:'âŒ¨ï¸',desc:'Input buttons.'},
      {name:'Joystick',icon:'ðŸ•¹ï¸',desc:'Directional input.'},
      {name:'Potentiometer',icon:'ðŸŽšï¸',desc:'Variable resistor.'},
      {name:'Rotary Encoder',icon:'ðŸ”„',desc:'Measures rotation.'},
      {name:'SD Card',icon:'ðŸ’¾',desc:'Storage.'},
      {name:'RTC',icon:'â°',desc:'Real time clock.'},
      {name:'Power Module',icon:'ðŸ”‹',desc:'Power supply.'},
      {name:'Battery',icon:'ðŸ”‹',desc:'Portable power.'},
      {name:'Solar Panel',icon:'ðŸ”†',desc:'Solar power.'},
      {name:'Fan',icon:'ðŸŒ€',desc:'Cooling.'},
      {name:'Pump',icon:'ðŸ’§',desc:'Moves fluids.'},
      {name:'Valve',icon:'ðŸšª',desc:'Controls flow.'},
      {name:'Laser',icon:'ðŸ”¦',desc:'Laser emitter.'},
      {name:'Thermocouple',icon:'ðŸŒ¡ï¸',desc:'Temperature probe.'},
      {name:'Load Cell',icon:'âš–ï¸',desc:'Measures weight.'}
    ];
    function renderModuleLibrary(filter='') {
      const lib = document.getElementById('module-library');
      lib.innerHTML = '';
      MODULES.filter(m => m.name.toLowerCase().includes(filter.toLowerCase())).forEach(m => {
        const d = document.createElement('div');
        d.className = 'module-item';
        d.style = 'padding:8px 0;display:flex;align-items:center;gap:10px;cursor:grab;border-bottom:1px solid var(--panel-alt);';
        d.innerHTML = `<span style='font-size:1.5em;'>${m.icon}</span><span><b>${m.name}</b><br><span style='font-size:0.9em;color:var(--msg-meta);'>${m.desc}</span></span>`;
        d.draggable = true;
        d.ondragstart = e => { e.dataTransfer.setData('text/plain', m.name); };
        lib.appendChild(d);
      });
    }
    document.getElementById('module-search').oninput = e => renderModuleLibrary(e.target.value);
    renderModuleLibrary();
    // Drag-and-drop for robot canvas
    const robotCanvas = document.getElementById('robot-canvas');
    robotCanvas.ondragover = e => { e.preventDefault(); robotCanvas.style.background='#e0f7fa'; };
    robotCanvas.ondragleave = e => { robotCanvas.style.background='var(--panel-alt)'; };
    robotCanvas.ondrop = e => {
      e.preventDefault();
      robotCanvas.style.background='var(--panel-alt)';
      const moduleName = e.dataTransfer.getData('text/plain');
      const m = MODULES.find(x => x.name === moduleName);
      if (m) {
        const el = document.createElement('div');
        el.className = 'robot-module';
        el.style = `position:absolute;left:${e.offsetX-20}px;top:${e.offsetY-20}px;padding:6px 10px;background:var(--panel);border-radius:8px;border:1px solid var(--accent2);box-shadow:0 1px 4px #0001;cursor:move;`;
        el.innerHTML = `<span style='font-size:1.3em;'>${m.icon}</span> <b>${m.name}</b>`;
        el.draggable = true;
        el.ondragstart = ev => { ev.dataTransfer.setData('text/plain', m.name); };
        robotCanvas.appendChild(el);
      }
    };
    // Schematic upload and AI analysis (placeholder)
    document.getElementById('analyze-schematic-btn').onclick = async function() {
      const fileInput = document.getElementById('schematic-upload');
      const analysisDiv = document.getElementById('schematic-analysis');
      if (!fileInput.files[0]) { analysisDiv.textContent = 'Please upload a schematic file.'; return; }
      analysisDiv.textContent = 'Analyzing...';
      const formData = new FormData();
      formData.append('file', fileInput.files[0]);
      const resp = await fetch('/analyze_schematic', { method: 'POST', body: formData });
      const data = await resp.json();
      if (data.status === 'ok') {
        analysisDiv.innerHTML = `<b>Modules Detected:</b> ${data.modules.join(', ')}<br><b>Suggested Trait Mapping:</b> ${data.trait_mapping}`;
      } else {
        analysisDiv.textContent = 'Analysis failed.';
      }
    };
    // Microcontroller detection and firmware upload
    document.getElementById('scan-mcu-btn').onclick = async function() {
      const status = document.getElementById('mcu-scan-status');
      status.textContent = 'Scanning...';
      const resp = await fetch('/detect_microcontroller');
      const data = await resp.json();
      if (data.status === 'ok') {
        detectedMCUs = data.devices;
        const sel = document.getElementById('mcu-select');
        sel.innerHTML = '';
        data.devices.forEach((d, i) => {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = `${d.type} (${d.port})`;
          sel.appendChild(opt);
        });
        status.textContent = data.devices.length ? 'Select a device.' : 'No microcontrollers found.';
      } else {
        status.textContent = 'Scan failed.';
      }
    };
    document.getElementById('upload-firmware-btn').onclick = async function() {
      const sel = document.getElementById('mcu-select');
      const idx = sel.value;
      if (!detectedMCUs[idx]) { document.getElementById('firmware-upload-status').textContent = 'No device selected.'; return; }
      const mcu = detectedMCUs[idx];
      const code = document.getElementById('firmware-code').value;
      const fileInput = document.getElementById('firmware-file');
      let firmware_path = '';
      if (fileInput.files[0]) {
        // In a real system, you would upload the file to the server and get a path
        // For now, just show a message
        document.getElementById('firmware-upload-status').textContent = 'Firmware file upload not implemented in this demo.';
        return;
      }
      const payload = { type: mcu.type, port: mcu.port, code };
      document.getElementById('firmware-upload-status').textContent = 'Uploading...';
      const resp = await fetch('/upload_firmware', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await resp.json();
      if (data.status === 'ok') {
        document.getElementById('firmware-upload-status').textContent = 'Upload successful!\n' + data.logs;
      } else {
        document.getElementById('firmware-upload-status').textContent = 'Upload failed.\n' + (data.logs || data.error);
      }
    };
    // Initialize with default tab
    showTab('traits-view');

    // --- Prototyping Canvas Logic ---
    const MCU_PINOUTS = {
      arduino: ["D2","D3","D4","D5","D6","D7","D8","D9","D10","D11","D12","D13","A0","A1","A2","A3","A4","A5","5V","GND"],
      esp32: ["GPIO2","GPIO4","GPIO5","GPIO12","GPIO13","GPIO14","GPIO15","GPIO16","GPIO17","GPIO18","GPIO19","GPIO21","GPIO22","GPIO23","3V3","GND"],
      stm32: ["PA0","PA1","PA2","PA3","PA4","PA5","PA6","PA7","PB0","PB1","PB10","PB11","PB12","PB13","PB14","PB15","3V3","GND"],
      pico: ["GP0","GP1","GP2","GP3","GP4","GP5","GP6","GP7","GP8","GP9","GP10","GP11","GP12","GP13","GP14","GP15","3V3","GND"]
    };
    const MODULE_PINOUTS = {
      "Ultrasonic Sensor": ["VCC","GND","Trig","Echo"],
      "Servo Motor": ["VCC","GND","Signal"],
      "LED": ["Anode","Cathode"],
      "Buzzer": ["+","-"],
      "Camera": ["VCC","GND","SDA","SCL"],
      "Temperature Sensor": ["VCC","GND","Signal"]
    };
    let protoModules = [];
    let protoConnections = [];
    let protoSelectedPin = null;
    function renderProtoMCU() {
      const mcuType = document.getElementById('mcu-board-select').value;
      const pins = MCU_PINOUTS[mcuType] || [];
      const mcuDiv = document.getElementById('proto-mcu');
      mcuDiv.innerHTML = `<div style='width:120px;height:180px;background:var(--panel);border:2px solid var(--accent);border-radius:12px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;'><b style='margin-bottom:8px;'>${mcuType.toUpperCase()}</b>${pins.map((p,i)=>`<div class='mcu-pin' data-pin='${p}' style='margin:2px 0;padding:2px 8px;border-radius:6px;background:var(--panel-alt);border:1px solid var(--accent2);cursor:pointer;font-size:0.95em;' onclick='protoPinClick("mcu","${p}")'>${p}</div>`).join('')}</div>`;
    }
    function renderProtoModules() {
      const modDiv = document.getElementById('proto-modules');
      modDiv.innerHTML = '';
      protoModules.forEach((mod, idx) => {
        const pins = MODULE_PINOUTS[mod.name] || ["VCC","GND","Signal"];
        const modEl = document.createElement('div');
        modEl.className = 'proto-module';
        modEl.style = `position:absolute;left:${mod.x}px;top:${mod.y}px;width:110px;background:var(--panel);border:2px solid var(--accent2);border-radius:10px;padding:8px;z-index:2;`;
        modEl.innerHTML = `<b>${mod.name}</b><br>${pins.map(p=>`<div class='mod-pin' data-mod='${idx}' data-pin='${p}' style='margin:2px 0;padding:2px 8px;border-radius:6px;background:var(--panel-alt);border:1px solid var(--accent2);cursor:pointer;font-size:0.95em;' onclick='protoPinClick("mod",${idx},"${p}")'>${p}</div>`).join('')}`;
        modDiv.appendChild(modEl);
      });
    }
    window.protoPinClick = function(type, modIdxOrPin, pinName) {
      if (!protoSelectedPin) {
        protoSelectedPin = {type, modIdxOrPin, pinName};
      } else {
        // Connect if one is mcu and one is mod
        if ((protoSelectedPin.type === 'mcu' && type === 'mod') || (protoSelectedPin.type === 'mod' && type === 'mcu')) {
          let from, to;
          if (protoSelectedPin.type === 'mod') {
            from = {mod: protoSelectedPin.modIdxOrPin, pin: protoSelectedPin.pinName};
            to = {mcu: modIdxOrPin, pin: pinName};
          } else {
            from = {mod: modIdxOrPin, pin: pinName};
            to = {mcu: protoSelectedPin.modIdxOrPin, pin: protoSelectedPin.pinName};
          }
          protoConnections.push({from, to});
          protoSelectedPin = null;
          renderProtoWires();
          renderProtoConnectionData();
        } else {
          protoSelectedPin = {type, modIdxOrPin, pinName};
        }
      }
    };
    function renderProtoWires() {
      const svg = document.getElementById('proto-wires');
      svg.innerHTML = '';
      // For demo, just draw straight lines between module and mcu (not accurate positions)
      protoConnections.forEach(conn => {
        // Find module and mcu pin positions
        // For now, use rough positions
        let x1 = 200, y1 = 40 + (conn.from.mod !== undefined ? conn.from.mod*60 : 0) + (conn.from.pin === 'VCC' ? 10 : conn.from.pin === 'GND' ? 30 : 50);
        let x2 = 80, y2 = 100 + (MCU_PINOUTS[document.getElementById('mcu-board-select').value].indexOf(conn.to.pin))*8;
        svg.innerHTML += `<line x1='${x1}' y1='${y1}' x2='${x2}' y2='${y2}' stroke='var(--accent)' stroke-width='3' marker-end='url(#arrowhead)'/>`;
      });
      svg.innerHTML += `<defs><marker id='arrowhead' markerWidth='8' markerHeight='8' refX='4' refY='4' orient='auto' markerUnits='strokeWidth'><path d='M0,0 L8,4 L0,8 L2,4 z' fill='var(--accent)'/></marker></defs>`;
    }
    function renderProtoConnectionData() {
      const div = document.getElementById('proto-connection-data');
      if (protoConnections.length === 0) { div.textContent = 'No connections yet.'; return; }
      div.innerHTML = protoConnections.map(conn => {
        let modName = protoModules[conn.from.mod]?.name || '?';
        return `${modName} [${conn.from.pin}] â†’ MCU [${conn.to.pin}]`;
      }).join('<br>');
    }
    document.getElementById('mcu-board-select').onchange = function() {
      renderProtoMCU();
      renderProtoWires();
      renderProtoConnectionData();
    };
    // Drag modules from library to prototyping canvas
    const protoCanvas = document.getElementById('proto-canvas-container');
    protoCanvas.ondragover = e => { e.preventDefault(); };
    protoCanvas.ondrop = e => {
      e.preventDefault();
      const moduleName = e.dataTransfer.getData('text/plain');
      if (!moduleName) return;
      protoModules.push({name: moduleName, x: e.offsetX, y: e.offsetY});
      renderProtoModules();
      renderProtoWires();
      renderProtoConnectionData();
    };
    renderProtoMCU();
    renderProtoModules();
    renderProtoWires();
    renderProtoConnectionData();
  </script>
</body>
</html>